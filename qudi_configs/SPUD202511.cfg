#  Example Qudi configuration file.
#  The recommended path for user specific files is C:\Users\<user_name>\qudi\config

global:
    # list of modules to load when starting
    startup_modules: []

    # Module server configuration for accessing qudi GUI/logic/hardware modules from remote clients
    remote_modules_server:
        address: 'localhost'
        port: 12345

    # Server port for serving the active qudi module namespace locally (localhost).
    # Used by e.g. the Qudi jupyter kernel.
    namespace_server_port: 18861

    # If this flag is set (True), all arguments passed to qudi module APIs from remote
    # (jupyter notebook, qudi console, remote modules) will be wrapped and passed "per value"
    # (serialized and de-serialized). This is avoiding a lot of inconveniences with using numpy in
    # remote clients.
    # If you do not want to use this workaround and know what you are doing, you can disable this
    # feature by setting this flag to False.
    force_remote_calls_by_value: True

    # Qss stylesheet for controlling the appearance of the GUIs.
    # Absolute path or relative to qudi.artwork.styles
    stylesheet: 'qdark.qss'

    # Default root directory for measurement data storage. All eventual data sub-directories should
    # be contained within this directory. This is not enforced, just convention.
    # The fallback directory is <user home>/qudi/Data/
    default_data_dir: C:\Users\SPUD1\Documents\experiment_workspace\qudi_data

    # Save data to daily data sub-directories by default
    daily_data_dirs: True

gui:
    scanner_gui:
        module.Class: 'scanning.scannergui.ScannerGui'
        options:
            image_axes_padding: 0.02
            default_position_unit_prefix: null  # optional, use unit prefix characters, e.g. 'u' or 'n'
            optimizer_plot_dimensions: [2,1]
        connect:
            scanning_logic: scanning_probe_logic
            data_logic: scanning_data_logic
            optimize_logic: scanning_optimize_logic

    laser_gui:
        module.Class: 'laser.laser_gui.LaserGui'
        connect:
            laser_logic: laser_logic
    
    odmr_gui:
        module.Class: 'odmr.odmrgui.OdmrGui'
        connect:
            odmr_logic: 'odmr_logic'
    
    laser_switch_gui:
        module.Class: 'switch.switch_gui.SwitchGui'
        connect:
            switchlogic: 'laser_switch_logic'

    qm_switch_gui:
        module.Class: 'switch.switch_gui.SwitchGui'
        connect:
            switchlogic: 'qm_switch_logic'

    pulsed_gui:
        module.Class: 'pulsed.pulsed_maingui.PulsedMeasurementGui'
        connect:
            pulsedmasterlogic: 'pulsed_master_logic'

    qdplot_gui:
        module.Class: 'qdplot.qdplot_gui.QDPlotterGui'
        connect:
            qdplot_logic: 'qdplot_logic'

    APD_gui:
        module.Class: 'time_series.time_series_gui.TimeSeriesGui'
        options:
            use_antialias: True  # optional, set to False if you encounter performance issues
        connect:
            _time_series_logic_con: time_series_reader_logic

    SPC3_gui:
        module.Class: 'camera.cameragui_SPC3.CameraGui'
        connect:
            camera_logic: camera_logic


logic:
    scanning_probe_logic:
        module.Class: 'scanning_probe_logic.ScanningProbeLogic'
        options:
            max_history_length: 20
            max_scan_update_interval: 2
            position_update_interval: 1
        connect:
            scanner: ni_scanner 

    scanning_data_logic:
        module.Class: 'scanning_data_logic.ScanningDataLogic'
        options:
            max_history_length: 20
        connect:
            scan_logic: scanning_probe_logic

    scanning_optimize_logic:
        module.Class: 'scanning_optimize_logic.ScanningOptimizeLogic'
        connect:
            scan_logic: scanning_probe_logic

    poi_manager_logic:
        module.Class: 'poi_manager_logic.PoiManagerLogic'
        connect:
            scanning_logic: 'scanning_probe_logic'
            optimize_logic: 'scanning_optimize_logic'
            data_logic: 'scanning_data_logic'

    laser_logic:
        module.Class: 'laser_logic.LaserLogic'
        options:
            query_interval: 0.1
        connect:
            #laser: 'laser_dummy'
            laser: 'dlnsec_laser'

    odmr_logic:
        module.Class: 'odmr_logic_shg.OdmrLogic'
        connect:
            microwave:  'mw_source_srssg'
            #microwave:  'mw_source_synthhd'
            #data_scanner: 'finite_sampling_input_dummy'
            data_scanner: ni_finite_sampling_input

    #switch_logic:
    #    module.Class: 'switch_logic.SwitchLogic'
    #    options:
    #        watchdog_interval: 1
    #        autostart_watchdog: True
    #    connect:
    #        switch: 'switch_interfuse'

    pulsed_master_logic:
        module.Class: 'pulsed.pulsed_master_logic.PulsedMasterLogic'
        connect:
            pulsedmeasurementlogic: 'pulsed_measurement_logic'
            sequencegeneratorlogic: 'sequence_generator_logic'


    pulsed_measurement_logic:
        module.Class: 'pulsed.pulsed_measurement_logic.PulsedMeasurementLogic'
        options:
            raw_data_save_type: 'text'
            #additional_extraction_path:
            #additional_analysis_path:
        connect:
            fastcounter: 'fast_counter_dummy'
            #microwave: 'microwave_dummy'
            pulsegenerator: 'pulser_dummy'

    qdplot_logic:
        module.Class: 'qdplot_logic.QDPlotLogic'
    
    time_series_reader_logic:
        module.Class: 'time_series_reader_logic.TimeSeriesReaderLogic'
        options:
            max_frame_rate: 20  # optional (10Hz by default)
            calc_digital_freq: True  # optional (True by default)
            #channel_buffer_size: 1048576  # optional (default: 1MSample)
            #max_raw_data_bytes: 1073741824  # optional (default: 1GB)
        connect:
            streamer: ni_instreamer
    
    laser_switch_logic:
        module.Class: 'switch_logic.SwitchLogic'
        options:
            watchdog_interval: 1  # optional
            autostart_watchdog: True  # optional
        connect:
            switch: laser_switch_ni

    qm_switch_logic:
        module.Class: 'switch_logic.SwitchLogic'
        options:
            watchdog_interval: 1  # optional
            autostart_watchdog: True  # optional
        connect:
            switch: qm_switch_ni

    camera_logic:
        module.Class: 'camera_logic_SPC3.CameraLogic'
        connect:
            camera: 'camera_SPC3'

hardware:
    zaber_motor:
            module.Class: 'motor.zaber_motion_magnet.ZaberStage'
            options:
                port: 'COM3'
                axis_label: 'x'

    dlnsec_laser:
        module.Class: 'laser.dlnsec_laser_qudi.DlnsecLaser'
        options:
            port: 'COM4'

    mw_source_srssg:
                module.Class: 'microwave.mw_source_srssg_shg.MicrowaveSRSSG'
                options:
                    comm_protocol: 'TCPIP'
                    #visa_address: 'TCPIP::18.25.11.6::inst0::INSTR'
                    visa_address: 'TCPIP::18.25.11.6::5025::SOCKET'
                    comm_timeout: 10
    
    ni_finite_sampling_input:
            module.Class: 'ni_x_series.ni_x_series_finite_sampling_input.NIXSeriesFiniteSamplingInput'
            options:
                device_name: 'Dev1'
                digital_channel_units:  # optional
                    'PFI15': 'c/s'
                    #'PFI8': 'c/s'  
                #analog_channel_units:  # optional #shg comment 20240626 
                #    'ai0': 'V'
                #    'ai1': 'V'
                # external_sample_clock_source: 'PFI0'  # optional
                # external_sample_clock_frequency: 1000  # optional
                adc_voltage_range: [-10, 10]  # optional, default [-10, 10]
                max_channel_samples_buffer: 10000000  # optional, default 10000000
                read_write_timeout: 10  # optional, default 10
                #sample_clock_output: '/Dev1/PFI8'  # optional, commenting out enabled connection to DAC #shg uncommented 20240626 #au commented 202511
                trigger_edge: RISING  # optional

    ni_scanner:
        module.Class: 'interfuse.ni_scanning_probe_interfuse.NiScanningProbeInterfuse'
        connect:
            scan_hardware: 'ni_finite_sampling_io'
            analog_output: 'ni_ao'
        options:  
            ni_channel_mapping:
                x: 'ao0'
                y: 'ao1'
                z: 'ao2'
                APD1: 'PFI15'
                #APD2: 'PFI9'
                #APD3: 'PFI10'
                #AI0: 'ai0'
            position_ranges: # in m
                x: [0, 200e-6]
                y: [0, 200e-6]
                z: [0, 200e-6] #z: [-100e-6, 100e-6]
            frequency_ranges: #in Hz
                x: [1, 100] #changeed from [1,5000] # data sheet: 32 ms/200 um
                y: [1, 100] #changeed from [1,5000] # data sheet: 40 ms/200 um
                z: [1, 100] #changeed from [1,5000] # data sheet: 54 ms/200 um
            resolution_ranges:
                x: [1, 10000]
                y: [1, 10000]
                z: [1, 10000]
            input_channel_units:
                APD1: 'c/s'
                #APD2: 'c/s'
                #APD3: 'c/s'
                #AI0: 'V'
            default_backward_resolution: 50 # optional #backwards_line_resolution: 50 # optional
            move_velocity: 40e-6 #m/s changed from 400e-6 TODO actual HW constraint? #maximum_move_velocity
    
    
    ni_finite_sampling_io:
        module.Class: 'ni_x_series.ni_x_series_finite_sampling_io.NIXSeriesFiniteSamplingIO'
        options:
            device_name: 'Dev1'
            input_channel_units:  # optional
                PFI15: 'c/s'
                #PFI9: 'c/s'
                #PFI10: 'c/s'
                #ai0: 'V'
                #ai1: 'V'
            output_channel_units:
                'ao0': 'V'
                'ao1': 'V'
                'ao2': 'V'
            adc_voltage_ranges:
                #ai0: [-10, 10]  # optional
                #ai1: [-10, 10]  # optional
            output_voltage_ranges:
                ao0: [0, 10]
                ao1: [0, 10]
                ao2: [0, 10]
            frame_size_limits: [1, 1e9]  # optional #TODO actual HW constraint?
            output_mode: 'JUMP_LIST' #'JUMP_LIST' # optional, must be name of SamplingOutputMode
            read_write_timeout: 10  # optional
            #sample_clock_output: '/Dev1/PFI11' # optional

    ni_ao:
        module.Class: 'ni_x_series.ni_x_series_analog_output.NIXSeriesAnalogOutput'
        options:
            device_name: 'Dev1'
            channels:
                ao0:
                    limits: [-10.0, 10.0]
                    keep_value: True
                ao1:
                    limits: [-10.0, 10.0]
                    keep_value: True
                ao2:
                    limits: [-10.0, 10.0]
                    keep_value: True
                #ao3:
                #    limits: [-10.0, 10.0]
                #    keep_value: True

    ni_instreamer:
        module.Class: 'ni_x_series.ni_x_series_in_streamer.NIXSeriesInStreamer'
        options:
            device_name: 'Dev1'
            digital_sources:  # optional
                - 'PFI15'
            analog_sources:  # optional
                - 'ai0'
                #- 'ai1'
            # external_sample_clock_source: 'PFI0'  # optional
            # external_sample_clock_frequency: 1000  # optional
            adc_voltage_range: [-10, 10]  # optional
            max_channel_samples_buffer: 10000000  # optional
            read_write_timeout: 10  # optional
            
    laser_switch_ni:
        module.Class: 'switches.digital_switch_ni.DigitalSwitchNI'
        options:
            #channel: '/Dev1/port0/line30:31'  # optional
            channel: '/Dev1/port0/line0'  # optional
            name: 'Laser Mode Relay'  # optional
            switch_time: 0.1
            remember_states: True
            switches:                       # optional
                One: ['Low', 'High']
                #Two: ['Off', 'On']

    qm_switch_ni:
        module.Class: 'switches.digital_switch_ni.DigitalSwitchNI'
        options:
            #channel: '/Dev1/port0/line30:31'  # optional
            channel: '/Dev1/port0/line1'  # optional
            name: 'AWG trigger'  # optional
            switch_time: 0.1
            remember_states: True
            switches:                       # optional
                One: ['Low', 'High']
                #Two: ['Off', 'On']
    
    camera_SPC3:
        module.Class: 'camera.SPC3.spc3_qudi.SPC3_Qudi'  # changed from IxonUltra to SPC3 20240626
        options:
            dll_location: C:\Users\SPUD1\Documents\qudi_workspace_202401\qudi-iqo-modules\src\qudi\hardware\camera\SPC3\lib\Win\
            camera_mode: 0  # 0: Normal, 1: Advanced
            default_exposure: .02 # (.02 for 50fps) reciprocal of frame acquisition rate, in seconds #for gui display only
            default_hardware_integration: 52e-6 # in seconds (camera internal exposure time) #advanced mode only #10.4 microseconds for normal mode
            default_NFrames: 10 #Used for SNAP mode only
            default_NIntegFrames: 5 # frames from camera = 1 / (hardware_integration * NIntegFrames) #max 65535
            default_NCounters: 1
            default_Force8bit: 0  # 0: disabled, 1: enabled
            default_Half_array: 0  # 0: disabled, 1: enabled
            default_Signed_data: 0  # 0: disabled, 1: enabled
            default_Gate_Mode: 0  # 0: Fast, 1: Flim, 2: Coarse
            default_trigger_mode: 1  # '0' for single trigger, '1-100' for continuous triggering, -1 for no trigger

            

